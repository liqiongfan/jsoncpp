/* Generated by re2c 2.0.3 */
#include <cstdlib>
#include <iostream>
#include "json_language.hh"



#define YYCURSOR  l.start
#define YYLIMIT   l.limit
#define YYMARKER  l.marker
#define YYCTXMARKER l.ctxmarker
#define YYCTYPE unsigned char
#define YYGETCONDITION() l.state
#define YYSETCONDITION(cond) l.state=(yyc##cond)
#define GOTO(cond) goto yyc_##cond
#define SETANDJUMPTO(cond) YYSETCONDITION(cond); GOTO(cond)
#define FORWARD(lines, columns) l.line += (lines); l.column += (columns)
#define LOCATION yy::parser::location_type(nullptr, yy::location::counter_type(l.line), yy::location::counter_type(l.column))

yy::parser::symbol_type kk_lex(scanner &l) {

std:
    std::string data;
    char *begin = l.start;
skip:


	{
		YYCTYPE yych;
		unsigned int yyaccept = 0;
		if (YYGETCONDITION() < 2) {
			if (YYGETCONDITION() < 1) {
				goto yyc_JSON;
			} else {
				goto yyc_KEY;
			}
		} else {
			if (YYGETCONDITION() < 3) {
				goto yyc_KEY1;
			} else {
				if (YYGETCONDITION() < 4) {
					goto yyc_COMMENTS;
				} else {
					goto yyc_COMMENT_STR1;
				}
			}
		}
/* *********************************** */
yyc_JSON:
		{
			static const unsigned char yybm[] = {
				  0,   0,   0,   0,   0,   0,   0,   0, 
				  0,  16,   0,   0,   0,  16,   0,   0, 
				  0,   0,   0,   0,   0,   0,   0,   0, 
				  0,   0,   0,   0,   0,   0,   0,   0, 
				 16,   0,   0,   0,   0,   0,   0,   0, 
				  0,   0,   0,   0,   0,   0,   0,   0, 
				224, 224, 224, 224, 224, 224, 224, 224, 
				224, 224,   0,   0,   0,   0,   0,   0, 
				  0, 192, 192, 192, 192, 192, 192,  64, 
				 64,  64,  64,  64,  64,  64,  64,  64, 
				 64,  64,  64,  64,  64,  64,  64,  64, 
				 64,  64,  64,   0,   0,   0,   0,  64, 
				  0, 192, 192, 192, 192, 192, 192,  64, 
				 64,  64,  64,  64,  64,  64,  64,  64, 
				 64,  64,  64,  64,  64,  64,  64,  64, 
				 64,  64,  64,   0,   0,   0,   0,   0, 
				 64,  64,  64,  64,  64,  64,  64,  64, 
				 64,  64,  64,  64,  64,  64,  64,  64, 
				 64,  64,  64,  64,  64,  64,  64,  64, 
				 64,  64,  64,  64,  64,  64,  64,  64, 
				 64,  64,  64,  64,  64,  64,  64,  64, 
				 64,  64,  64,  64,  64,  64,  64,  64, 
				 64,  64,  64,  64,  64,  64,  64,  64, 
				 64,  64,  64,  64,  64,  64,  64,  64, 
				 64,  64,  64,  64,  64,  64,  64,  64, 
				 64,  64,  64,  64,  64,  64,  64,  64, 
				 64,  64,  64,  64,  64,  64,  64,  64, 
				 64,  64,  64,  64,  64,  64,  64,  64, 
				 64,  64,  64,  64,  64,  64,  64,  64, 
				 64,  64,  64,  64,  64,  64,  64,  64, 
				 64,  64,  64,  64,  64,  64,  64,  64, 
				 64,  64,  64,  64,  64,  64,  64,  64, 
			};
			yych = *YYCURSOR;
			switch (yych) {
			case 0x00:	goto yy3;
			case 0x01:
			case 0x02:
			case 0x03:
			case 0x04:
			case 0x05:
			case 0x06:
			case 0x07:
			case 0x08:
			case '\v':
			case '\f':
			case 0x0E:
			case 0x0F:
			case 0x10:
			case 0x11:
			case 0x12:
			case 0x13:
			case 0x14:
			case 0x15:
			case 0x16:
			case 0x17:
			case 0x18:
			case 0x19:
			case 0x1A:
			case 0x1B:
			case 0x1C:
			case 0x1D:
			case 0x1E:
			case 0x1F:
			case '!':
			case '$':
			case '%':
			case '&':
			case '(':
			case ')':
			case '*':
			case ';':
			case '<':
			case '=':
			case '>':
			case '?':
			case '@':
			case '\\':
			case '^':
			case '`':
			case '|':
			case '~':
			case 0x7F:	goto yy2;
			case '\t':
			case ' ':	goto yy5;
			case '\n':	goto yy8;
			case '\r':	goto yy10;
			case '"':	goto yy11;
			case '#':	goto yy13;
			case '\'':	goto yy15;
			case '+':	goto yy17;
			case ',':	goto yy18;
			case '-':	goto yy20;
			case '.':	goto yy21;
			case '/':	goto yy24;
			case '0':	goto yy25;
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':	goto yy27;
			case ':':	goto yy29;
			case 'F':
			case 'f':	goto yy34;
			case 'I':
			case 'i':	goto yy35;
			case 'N':
			case 'n':	goto yy36;
			case 'T':
			case 't':	goto yy37;
			case '[':	goto yy38;
			case ']':	goto yy40;
			case '{':	goto yy42;
			case '}':	goto yy44;
			default:	goto yy31;
			}
yy2:
			YYCURSOR = YYMARKER;
			if (yyaccept <= 1) {
				if (yyaccept == 0) {
					goto yy23;
				} else {
					goto yy26;
				}
			} else {
				if (yyaccept == 2) {
					goto yy70;
				} else {
					goto yy77;
				}
			}
yy3:
			++YYCURSOR;
			{
    return yy::parser::make_YYEOF(LOCATION);
}
yy5:
			yych = *++YYCURSOR;
yy6:
			if (yybm[0+yych] & 16) {
				goto yy5;
			}
			{ 
    FORWARD(0, l.start - begin); 
    goto std; 
}
yy8:
			++YYCURSOR;
			{
    FORWARD(1, 0);
    l.column = 0; 
    goto std;
}
yy10:
			yych = *++YYCURSOR;
			if (yych == '\n') goto yy8;
			goto yy6;
yy11:
			++YYCURSOR;
			{
    begin = l.start;
    l.subline = l.line;
    l.subcolumn = l.subcolumn;
    SETANDJUMPTO(KEY);
}
yy13:
			++YYCURSOR;
			{
    SETANDJUMPTO(COMMENTS);
}
yy15:
			++YYCURSOR;
			{
    begin = l.start;
    l.subline = l.line;
    l.subcolumn = l.subcolumn;
    SETANDJUMPTO(KEY1);
}
yy17:
			yych = *++YYCURSOR;
			if (yych <= 'H') {
				if (yych <= '/') goto yy2;
				if (yych <= '0') goto yy46;
				if (yych <= '9') goto yy27;
				goto yy2;
			} else {
				if (yych <= 'I') goto yy47;
				if (yych == 'i') goto yy47;
				goto yy2;
			}
yy18:
			++YYCURSOR;
			{ FORWARD(0, l.start - begin); return yy::parser::symbol_type(',', LOCATION); }
yy20:
			yych = *++YYCURSOR;
			if (yych <= 'H') {
				if (yych <= '/') goto yy2;
				if (yych <= '0') goto yy46;
				if (yych <= '9') goto yy27;
				goto yy2;
			} else {
				if (yych <= 'I') goto yy48;
				if (yych == 'i') goto yy48;
				goto yy2;
			}
yy21:
			yyaccept = 0;
			yych = *(YYMARKER = ++YYCURSOR);
			if (yybm[0+yych] & 32) {
				goto yy21;
			}
			if (yych == 'E') goto yy49;
			if (yych == 'e') goto yy49;
yy23:
			{
    FORWARD(0, l.start - begin);
    std::string str(begin, l.start);
    double d = std::strtod(str.data(), nullptr);
    return yy::parser::make_DOUBLE(d, LOCATION);
}
yy24:
			yych = *++YYCURSOR;
			if (yych == '*') goto yy50;
			if (yych == '/') goto yy52;
			goto yy2;
yy25:
			yyaccept = 1;
			yych = *(YYMARKER = ++YYCURSOR);
			if (yych <= 'W') {
				if (yych <= '.') {
					if (yych >= '.') goto yy21;
				} else {
					if (yych == 'E') goto yy49;
				}
			} else {
				if (yych <= 'e') {
					if (yych <= 'X') goto yy54;
					if (yych >= 'e') goto yy49;
				} else {
					if (yych == 'x') goto yy54;
				}
			}
yy26:
			{
    FORWARD(0, l.start - begin);
    std::string str(begin, l.start);
    long ll = std::strtol(str.data(), nullptr, 10);
    return yy::parser::make_INT(ll, LOCATION);
}
yy27:
			yyaccept = 1;
			yych = *(YYMARKER = ++YYCURSOR);
			if (yych <= '9') {
				if (yych == '.') goto yy21;
				if (yych <= '/') goto yy26;
				goto yy27;
			} else {
				if (yych <= 'E') {
					if (yych <= 'D') goto yy26;
					goto yy49;
				} else {
					if (yych == 'e') goto yy49;
					goto yy26;
				}
			}
yy29:
			++YYCURSOR;
			{ FORWARD(0, l.start - begin); return yy::parser::symbol_type(':', LOCATION); }
yy31:
			yych = *++YYCURSOR;
yy32:
			if (yybm[0+yych] & 64) {
				goto yy31;
			}
			{
    FORWARD(0, l.start - begin);
    std::string v(begin, l.start);
    return yy::parser::make_LABEL(v, LOCATION);
}
yy34:
			yych = *++YYCURSOR;
			if (yych == 'A') goto yy55;
			if (yych == 'a') goto yy55;
			goto yy32;
yy35:
			yych = *++YYCURSOR;
			if (yych == 'N') goto yy56;
			if (yych == 'n') goto yy56;
			goto yy32;
yy36:
			yych = *++YYCURSOR;
			if (yych <= 'U') {
				if (yych == 'A') goto yy57;
				if (yych <= 'T') goto yy32;
				goto yy58;
			} else {
				if (yych <= 'a') {
					if (yych <= '`') goto yy32;
					goto yy57;
				} else {
					if (yych == 'u') goto yy58;
					goto yy32;
				}
			}
yy37:
			yych = *++YYCURSOR;
			if (yych == 'R') goto yy59;
			if (yych == 'r') goto yy59;
			goto yy32;
yy38:
			++YYCURSOR;
			{ FORWARD(0, l.start - begin); return yy::parser::symbol_type('[', LOCATION); }
yy40:
			++YYCURSOR;
			{ FORWARD(0, l.start - begin); return yy::parser::symbol_type(']', LOCATION); }
yy42:
			++YYCURSOR;
			{ FORWARD(0, l.start - begin); return yy::parser::symbol_type('{', LOCATION); }
yy44:
			++YYCURSOR;
			{ FORWARD(0, l.start - begin); return yy::parser::symbol_type('}', LOCATION); }
yy46:
			yyaccept = 1;
			yych = *(YYMARKER = ++YYCURSOR);
			if (yych <= 'D') {
				if (yych == '.') goto yy21;
				goto yy26;
			} else {
				if (yych <= 'E') goto yy49;
				if (yych == 'e') goto yy49;
				goto yy26;
			}
yy47:
			yych = *++YYCURSOR;
			if (yych == 'N') goto yy60;
			if (yych == 'n') goto yy60;
			goto yy2;
yy48:
			yych = *++YYCURSOR;
			if (yych == 'N') goto yy61;
			if (yych == 'n') goto yy61;
			goto yy2;
yy49:
			yych = *++YYCURSOR;
			if (yych <= ',') {
				if (yych == '+') goto yy62;
				goto yy2;
			} else {
				if (yych <= '-') goto yy62;
				if (yych <= '/') goto yy2;
				if (yych <= '9') goto yy63;
				goto yy2;
			}
yy50:
			++YYCURSOR;
			{
    l.subline = l.line;
    l.subcolumn = l.column;
    SETANDJUMPTO(COMMENT_STR1);
}
yy52:
			++YYCURSOR;
			{
    SETANDJUMPTO(COMMENTS);
}
yy54:
			yych = *++YYCURSOR;
			if (yybm[0+yych] & 128) {
				goto yy65;
			}
			goto yy2;
yy55:
			yych = *++YYCURSOR;
			if (yych == 'L') goto yy68;
			if (yych == 'l') goto yy68;
			goto yy32;
yy56:
			yych = *++YYCURSOR;
			if (yych == 'F') goto yy69;
			if (yych == 'f') goto yy69;
			goto yy32;
yy57:
			yych = *++YYCURSOR;
			if (yych == 'N') goto yy71;
			if (yych == 'n') goto yy71;
			goto yy32;
yy58:
			yych = *++YYCURSOR;
			if (yych == 'L') goto yy73;
			if (yych == 'l') goto yy73;
			goto yy32;
yy59:
			yych = *++YYCURSOR;
			if (yych == 'U') goto yy74;
			if (yych == 'u') goto yy74;
			goto yy32;
yy60:
			yych = *++YYCURSOR;
			if (yych == 'F') goto yy75;
			if (yych == 'f') goto yy75;
			goto yy2;
yy61:
			yych = *++YYCURSOR;
			if (yych == 'F') goto yy76;
			if (yych == 'f') goto yy76;
			goto yy2;
yy62:
			yych = *++YYCURSOR;
			if (yych <= '/') goto yy2;
			if (yych >= ':') goto yy2;
yy63:
			yych = *++YYCURSOR;
			if (yych <= '/') goto yy23;
			if (yych <= '9') goto yy63;
			goto yy23;
yy65:
			yych = *++YYCURSOR;
			if (yybm[0+yych] & 128) {
				goto yy65;
			}
			{
    FORWARD(0, l.start - begin);
    std::string str(begin, l.start);
    long ll = std::strtol(str.data(), nullptr, 16);
    return yy::parser::make_HEX(json::hex(ll, str), LOCATION);
}
yy68:
			yych = *++YYCURSOR;
			if (yych == 'S') goto yy78;
			if (yych == 's') goto yy78;
			goto yy32;
yy69:
			yych = *++YYCURSOR;
			if (yych <= '^') {
				if (yych <= '@') {
					if (yych <= '/') goto yy70;
					if (yych <= '9') goto yy31;
				} else {
					if (yych == 'I') goto yy79;
					if (yych <= 'Z') goto yy31;
				}
			} else {
				if (yych <= 'h') {
					if (yych != '`') goto yy31;
				} else {
					if (yych <= 'i') goto yy79;
					if (yych <= 'z') goto yy31;
					if (yych >= 0x80) goto yy31;
				}
			}
yy70:
			{ FORWARD(0, l.start - begin); return yy::parser::make_INF(json::infinity(false), LOCATION);         }
yy71:
			yych = *++YYCURSOR;
			if (yybm[0+yych] & 64) {
				goto yy31;
			}
			{ FORWARD(0, l.start - begin); return yy::parser::make_NANN(json::nan(), LOCATION);                  }
yy73:
			yych = *++YYCURSOR;
			if (yych == 'L') goto yy80;
			if (yych == 'l') goto yy80;
			goto yy32;
yy74:
			yych = *++YYCURSOR;
			if (yych == 'E') goto yy82;
			if (yych == 'e') goto yy82;
			goto yy32;
yy75:
			yyaccept = 2;
			yych = *(YYMARKER = ++YYCURSOR);
			if (yych == 'I') goto yy84;
			if (yych == 'i') goto yy84;
			goto yy70;
yy76:
			yyaccept = 3;
			yych = *(YYMARKER = ++YYCURSOR);
			if (yych == 'I') goto yy85;
			if (yych == 'i') goto yy85;
yy77:
			{ FORWARD(0, l.start - begin); return yy::parser::make_INF(json::infinity(true), LOCATION);          }
yy78:
			yych = *++YYCURSOR;
			if (yych == 'E') goto yy86;
			if (yych == 'e') goto yy86;
			goto yy32;
yy79:
			yych = *++YYCURSOR;
			if (yych == 'N') goto yy88;
			if (yych == 'n') goto yy88;
			goto yy32;
yy80:
			yych = *++YYCURSOR;
			if (yybm[0+yych] & 64) {
				goto yy31;
			}
			{ FORWARD(0, l.start - begin); return yy::parser::make_NUL(json::null(), LOCATION);                  }
yy82:
			yych = *++YYCURSOR;
			if (yybm[0+yych] & 64) {
				goto yy31;
			}
			{ FORWARD(0, l.start - begin); return yy::parser::make_BOOLEAN(json::boolean(true), LOCATION);       }
yy84:
			yych = *++YYCURSOR;
			if (yych == 'N') goto yy89;
			if (yych == 'n') goto yy89;
			goto yy2;
yy85:
			yych = *++YYCURSOR;
			if (yych == 'N') goto yy90;
			if (yych == 'n') goto yy90;
			goto yy2;
yy86:
			yych = *++YYCURSOR;
			if (yybm[0+yych] & 64) {
				goto yy31;
			}
			{ FORWARD(0, l.start - begin); return yy::parser::make_BOOLEAN(json::boolean(false), LOCATION);      }
yy88:
			yych = *++YYCURSOR;
			if (yych == 'I') goto yy91;
			if (yych == 'i') goto yy91;
			goto yy32;
yy89:
			yych = *++YYCURSOR;
			if (yych == 'I') goto yy92;
			if (yych == 'i') goto yy92;
			goto yy2;
yy90:
			yych = *++YYCURSOR;
			if (yych == 'I') goto yy93;
			if (yych == 'i') goto yy93;
			goto yy2;
yy91:
			yych = *++YYCURSOR;
			if (yych == 'T') goto yy94;
			if (yych == 't') goto yy94;
			goto yy32;
yy92:
			yych = *++YYCURSOR;
			if (yych == 'T') goto yy95;
			if (yych == 't') goto yy95;
			goto yy2;
yy93:
			yych = *++YYCURSOR;
			if (yych == 'T') goto yy96;
			if (yych == 't') goto yy96;
			goto yy2;
yy94:
			yych = *++YYCURSOR;
			if (yych == 'Y') goto yy97;
			if (yych == 'y') goto yy97;
			goto yy32;
yy95:
			yych = *++YYCURSOR;
			if (yych == 'Y') goto yy99;
			if (yych == 'y') goto yy99;
			goto yy2;
yy96:
			yych = *++YYCURSOR;
			if (yych == 'Y') goto yy100;
			if (yych == 'y') goto yy100;
			goto yy2;
yy97:
			yych = *++YYCURSOR;
			if (yybm[0+yych] & 64) {
				goto yy31;
			}
yy98:
			{ FORWARD(0, l.start - begin); return yy::parser::make_INF(json::infinity(false), LOCATION);    }
yy99:
			++YYCURSOR;
			goto yy98;
yy100:
			++YYCURSOR;
			{ FORWARD(0, l.start - begin); return yy::parser::make_INF(json::infinity(true), LOCATION);     }
		}
/* *********************************** */
yyc_KEY:
		yych = *YYCURSOR;
		if (yych <= '\v') {
			if (yych <= 0x08) {
				if (yych >= 0x01) goto yy106;
			} else {
				if (yych <= '\t') goto yy108;
				if (yych <= '\n') goto yy110;
				goto yy106;
			}
		} else {
			if (yych <= ' ') {
				if (yych <= '\f') goto yy108;
				if (yych <= 0x1F) goto yy106;
				goto yy108;
			} else {
				if (yych == '"') goto yy112;
				goto yy106;
			}
		}
		++YYCURSOR;
		{
    l.msg = "double-quotation-marks string unclosed";
    l.line = l.subline;
    l.column = l.subcolumn;
    goto syntax_error;
}
yy106:
		++YYCURSOR;
		{
    FORWARD(0, 1);
    SETANDJUMPTO(KEY);
}
yy108:
		++YYCURSOR;
		{
    FORWARD(0, 1);
    data = data.append(begin, l.start);
    begin=l.start;
    SETANDJUMPTO(KEY);
}
yy110:
		++YYCURSOR;
		{
    if (*(l.start-2) == '\r') {
        if (*(l.start-3) != '\\') {
            goto syntax_error;
        }
        data = data.append(begin, l.start-3);
    } else {
        if (*(l.start-2) != '\\') {
            goto syntax_error;
        }
        data = data.append(begin, l.start-2);
    }
    begin = l.start;
    FORWARD(1, 0);
    l.column = 0; 
    SETANDJUMPTO(KEY);
}
yy112:
		++YYCURSOR;
		{
    std::string v(begin, l.start-1);
    if (data.size() >= 1) {
        v = data + v;
    }
    data.clear();
    YYSETCONDITION(JSON);
    return yy::parser::make_STRING(v, LOCATION);
}
/* *********************************** */
yyc_KEY1:
		yych = *YYCURSOR;
		if (yych <= '\v') {
			if (yych <= 0x08) {
				if (yych >= 0x01) goto yy118;
			} else {
				if (yych <= '\t') goto yy120;
				if (yych <= '\n') goto yy122;
				goto yy118;
			}
		} else {
			if (yych <= ' ') {
				if (yych <= '\f') goto yy120;
				if (yych <= 0x1F) goto yy118;
				goto yy120;
			} else {
				if (yych == '\'') goto yy124;
				goto yy118;
			}
		}
		++YYCURSOR;
		{
    l.msg = "single-quotation-marks string unclosed";
    l.line = l.subline;
    l.column = l.subcolumn;
    goto syntax_error;
}
yy118:
		++YYCURSOR;
		{
    FORWARD(0, 1);
    SETANDJUMPTO(KEY1);
}
yy120:
		++YYCURSOR;
		{
    FORWARD(0, 1);
    data = data.append(begin, l.start);
    begin=l.start;
    SETANDJUMPTO(KEY1);
}
yy122:
		++YYCURSOR;
		{
    if (*(l.start-2) == '\r') {
        if (*(l.start-3) != '\\') {
            goto syntax_error;
        }
        data = data.append(begin, l.start-3);
    } else {
        if (*(l.start-2) != '\\') {
            goto syntax_error;
        }
        data = data.append(begin, l.start-2);
    }
    begin = l.start;
    FORWARD(1, 0);
    l.column = 0; 
    SETANDJUMPTO(KEY1);
}
yy124:
		++YYCURSOR;
		{
    std::string v(begin, l.start-1);
    if (data.size() >= 1) {
        v = data + v;
    }
    data.clear();
    YYSETCONDITION(JSON);
    return yy::parser::make_STRING(v, LOCATION);
}
/* *********************************** */
yyc_COMMENTS:
		yych = *YYCURSOR;
		if (yych == '\n') goto yy130;
		++YYCURSOR;
		{
    SETANDJUMPTO(COMMENTS);
}
yy130:
		++YYCURSOR;
		{
    FORWARD(1, 0);
    l.column = 0;
    SETANDJUMPTO(JSON);
}
/* *********************************** */
yyc_COMMENT_STR1:
		yych = *YYCURSOR;
		if (yych <= '\n') {
			if (yych <= 0x00) goto yy134;
			if (yych <= '\t') goto yy136;
			goto yy138;
		} else {
			if (yych == '*') goto yy140;
			goto yy136;
		}
yy134:
		++YYCURSOR;
		{
    l.msg = "multiline comments unclosed";
    l.line = l.subline;
    l.column = l.subcolumn;
    goto syntax_error;
}
yy136:
		++YYCURSOR;
yy137:
		{
    SETANDJUMPTO(COMMENT_STR1);
}
yy138:
		++YYCURSOR;
		{
    FORWARD(1, 0);
    l.column = 0;
    SETANDJUMPTO(COMMENT_STR1);
}
yy140:
		yych = *++YYCURSOR;
		if (yych != '/') goto yy137;
		++YYCURSOR;
		{
    begin = l.start;
    SETANDJUMPTO(JSON);
}
	}


syntax_error:
return yy::parser::make_YYerror(LOCATION);
}