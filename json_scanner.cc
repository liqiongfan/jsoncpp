/* Generated by re2c 2.0.3 */
#include <cstdlib>
#include <iostream>
#include "json_language.hh"



#define YYCURSOR  l.start
#define YYLIMIT   l.limit
#define YYMARKER  l.marker
#define YYCTXMARKER l.ctxmarker
#define YYCTYPE unsigned char
#define YYGETCONDITION() l.state
#define YYSETCONDITION(cond) l.state=(yyc##cond)
#define GOTO(cond) goto yyc_##cond
#define SETANDJUMPTO(cond) YYSETCONDITION(cond); GOTO(cond)
#define FORWARD(lines, columns) l.line += (lines); l.column += (columns)
#define LOCATION yy::parser::location_type(nullptr, yy::location::counter_type(l.line), yy::location::counter_type(l.column))

yy::parser::symbol_type kk_lex(scanner &l) {

std:
    std::string data;
    char *begin = l.start;
skip:


	{
		YYCTYPE yych;
		unsigned int yyaccept = 0;
		if (YYGETCONDITION() < 2) {
			if (YYGETCONDITION() < 1) {
				goto yyc_JSON;
			} else {
				goto yyc_KEY;
			}
		} else {
			if (YYGETCONDITION() < 3) {
				goto yyc_KEY1;
			} else {
				if (YYGETCONDITION() < 4) {
					goto yyc_COMMENTS;
				} else {
					goto yyc_COMMENT_STR1;
				}
			}
		}
/* *********************************** */
yyc_JSON:
		{
			static const unsigned char yybm[] = {
				  0,   0,   0,   0,   0,   0,   0,   0, 
				  0,  16,   0,   0,   0,  16,   0,   0, 
				  0,   0,   0,   0,   0,   0,   0,   0, 
				  0,   0,   0,   0,   0,   0,   0,   0, 
				 16,   0,   0,   0,   0,   0,   0,   0, 
				  0,   0,   0,   0,   0,   0,   0,   0, 
				 96,  96,  96,  96,  96,  96,  96,  96, 
				 96,  96,   0,   0,   0,   0,   0,   0, 
				  0, 192, 192, 192, 192, 192, 192,  64, 
				 64,  64,  64,  64,  64,  64,  64,  64, 
				 64,  64,  64,  64,  64,  64,  64,  64, 
				 64,  64,  64,   0,   0,   0,   0,  64, 
				  0, 192, 192, 192, 192, 192, 192,  64, 
				 64,  64,  64,  64,  64,  64,  64,  64, 
				 64,  64,  64,  64,  64,  64,  64,  64, 
				 64,  64,  64,   0,   0,   0,   0,   0, 
				 64,  64,  64,  64,  64,  64,  64,  64, 
				 64,  64,  64,  64,  64,  64,  64,  64, 
				 64,  64,  64,  64,  64,  64,  64,  64, 
				 64,  64,  64,  64,  64,  64,  64,  64, 
				 64,  64,  64,  64,  64,  64,  64,  64, 
				 64,  64,  64,  64,  64,  64,  64,  64, 
				 64,  64,  64,  64,  64,  64,  64,  64, 
				 64,  64,  64,  64,  64,  64,  64,  64, 
				 64,  64,  64,  64,  64,  64,  64,  64, 
				 64,  64,  64,  64,  64,  64,  64,  64, 
				 64,  64,  64,  64,  64,  64,  64,  64, 
				 64,  64,  64,  64,  64,  64,  64,  64, 
				 64,  64,  64,  64,  64,  64,  64,  64, 
				 64,  64,  64,  64,  64,  64,  64,  64, 
				 64,  64,  64,  64,  64,  64,  64,  64, 
				 64,  64,  64,  64,  64,  64,  64,  64, 
			};
			yych = *YYCURSOR;
			switch (yych) {
			case 0x00:	goto yy3;
			case 0x01:
			case 0x02:
			case 0x03:
			case 0x04:
			case 0x05:
			case 0x06:
			case 0x07:
			case 0x08:
			case '\v':
			case '\f':
			case 0x0E:
			case 0x0F:
			case 0x10:
			case 0x11:
			case 0x12:
			case 0x13:
			case 0x14:
			case 0x15:
			case 0x16:
			case 0x17:
			case 0x18:
			case 0x19:
			case 0x1A:
			case 0x1B:
			case 0x1C:
			case 0x1D:
			case 0x1E:
			case 0x1F:
			case '!':
			case '$':
			case '%':
			case '&':
			case '(':
			case ')':
			case '*':
			case ';':
			case '<':
			case '=':
			case '>':
			case '?':
			case '@':
			case '\\':
			case '^':
			case '`':
			case '|':
			case '~':
			case 0x7F:	goto yy2;
			case '\t':
			case ' ':	goto yy5;
			case '\n':	goto yy8;
			case '\r':	goto yy10;
			case '"':	goto yy11;
			case '#':	goto yy13;
			case '\'':	goto yy15;
			case '+':	goto yy17;
			case ',':	goto yy18;
			case '-':	goto yy20;
			case '.':	goto yy21;
			case '/':	goto yy24;
			case '0':	goto yy25;
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':	goto yy27;
			case ':':	goto yy29;
			case 'I':	goto yy34;
			case '[':	goto yy35;
			case ']':	goto yy37;
			case 'f':	goto yy39;
			case 'i':	goto yy40;
			case 'n':	goto yy41;
			case 't':	goto yy42;
			case '{':	goto yy43;
			case '}':	goto yy45;
			default:	goto yy31;
			}
yy2:
			YYCURSOR = YYMARKER;
			if (yyaccept == 0) {
				goto yy23;
			} else {
				goto yy26;
			}
yy3:
			++YYCURSOR;
			{
    return yy::parser::make_YYEOF(LOCATION);
}
yy5:
			yych = *++YYCURSOR;
yy6:
			if (yybm[0+yych] & 16) {
				goto yy5;
			}
			{ 
    FORWARD(0, l.start - begin); 
    goto std; 
}
yy8:
			++YYCURSOR;
			{
    FORWARD(1, 0);
    l.column = 0; 
    goto std;
}
yy10:
			yych = *++YYCURSOR;
			if (yych == '\n') goto yy8;
			goto yy6;
yy11:
			++YYCURSOR;
			{
    begin = l.start;
    l.subline = l.line;
    l.subcolumn = l.subcolumn;
    SETANDJUMPTO(KEY);
}
yy13:
			++YYCURSOR;
			{
    SETANDJUMPTO(COMMENTS);
}
yy15:
			++YYCURSOR;
			{
    begin = l.start;
    l.subline = l.line;
    l.subcolumn = l.subcolumn;
    SETANDJUMPTO(KEY1);
}
yy17:
			yych = *++YYCURSOR;
			if (yych <= 'H') {
				if (yych <= '/') goto yy2;
				if (yych <= '0') goto yy47;
				if (yych <= '9') goto yy27;
				goto yy2;
			} else {
				if (yych <= 'I') goto yy48;
				if (yych == 'i') goto yy49;
				goto yy2;
			}
yy18:
			++YYCURSOR;
			{ FORWARD(0, l.start - begin); return yy::parser::symbol_type(',', LOCATION); }
yy20:
			yych = *++YYCURSOR;
			if (yych <= 'H') {
				if (yych <= '/') goto yy2;
				if (yych <= '0') goto yy47;
				if (yych <= '9') goto yy27;
				goto yy2;
			} else {
				if (yych <= 'I') goto yy50;
				if (yych == 'i') goto yy51;
				goto yy2;
			}
yy21:
			yyaccept = 0;
			yych = *(YYMARKER = ++YYCURSOR);
			if (yybm[0+yych] & 32) {
				goto yy21;
			}
			if (yych == 'E') goto yy52;
			if (yych == 'e') goto yy52;
yy23:
			{
    FORWARD(0, l.start - begin);
    std::string str(begin, l.start);
    double d = std::strtod(str.data(), nullptr);
    return yy::parser::make_DOUBLE(d, LOCATION);
}
yy24:
			yych = *++YYCURSOR;
			if (yych == '*') goto yy53;
			if (yych == '/') goto yy55;
			goto yy2;
yy25:
			yyaccept = 1;
			yych = *(YYMARKER = ++YYCURSOR);
			if (yych <= 'W') {
				if (yych <= '.') {
					if (yych >= '.') goto yy21;
				} else {
					if (yych == 'E') goto yy52;
				}
			} else {
				if (yych <= 'e') {
					if (yych <= 'X') goto yy57;
					if (yych >= 'e') goto yy52;
				} else {
					if (yych == 'x') goto yy57;
				}
			}
yy26:
			{
    FORWARD(0, l.start - begin);
    std::string str(begin, l.start);
    long ll = std::strtol(str.data(), nullptr, 10);
    return yy::parser::make_INT(ll, LOCATION);
}
yy27:
			yyaccept = 1;
			yych = *(YYMARKER = ++YYCURSOR);
			if (yych <= '9') {
				if (yych == '.') goto yy21;
				if (yych <= '/') goto yy26;
				goto yy27;
			} else {
				if (yych <= 'E') {
					if (yych <= 'D') goto yy26;
					goto yy52;
				} else {
					if (yych == 'e') goto yy52;
					goto yy26;
				}
			}
yy29:
			++YYCURSOR;
			{ FORWARD(0, l.start - begin); return yy::parser::symbol_type(':', LOCATION); }
yy31:
			yych = *++YYCURSOR;
yy32:
			if (yybm[0+yych] & 64) {
				goto yy31;
			}
			{
    FORWARD(0, l.start - begin);
    std::string v(begin, l.start);
    return yy::parser::make_LABEL(v, LOCATION);
}
yy34:
			yych = *++YYCURSOR;
			if (yych == 'n') goto yy58;
			goto yy32;
yy35:
			++YYCURSOR;
			{ FORWARD(0, l.start - begin); return yy::parser::symbol_type('[', LOCATION); }
yy37:
			++YYCURSOR;
			{ FORWARD(0, l.start - begin); return yy::parser::symbol_type(']', LOCATION); }
yy39:
			yych = *++YYCURSOR;
			if (yych == 'a') goto yy59;
			goto yy32;
yy40:
			yych = *++YYCURSOR;
			if (yych == 'n') goto yy60;
			goto yy32;
yy41:
			yych = *++YYCURSOR;
			if (yych == 'u') goto yy61;
			goto yy32;
yy42:
			yych = *++YYCURSOR;
			if (yych == 'r') goto yy62;
			goto yy32;
yy43:
			++YYCURSOR;
			{ FORWARD(0, l.start - begin); return yy::parser::symbol_type('{', LOCATION); }
yy45:
			++YYCURSOR;
			{ FORWARD(0, l.start - begin); return yy::parser::symbol_type('}', LOCATION); }
yy47:
			yyaccept = 1;
			yych = *(YYMARKER = ++YYCURSOR);
			if (yych <= 'D') {
				if (yych == '.') goto yy21;
				goto yy26;
			} else {
				if (yych <= 'E') goto yy52;
				if (yych == 'e') goto yy52;
				goto yy26;
			}
yy48:
			yych = *++YYCURSOR;
			if (yych == 'n') goto yy63;
			goto yy2;
yy49:
			yych = *++YYCURSOR;
			if (yych == 'n') goto yy64;
			goto yy2;
yy50:
			yych = *++YYCURSOR;
			if (yych == 'n') goto yy65;
			goto yy2;
yy51:
			yych = *++YYCURSOR;
			if (yych == 'n') goto yy66;
			goto yy2;
yy52:
			yych = *++YYCURSOR;
			if (yych <= ',') {
				if (yych == '+') goto yy67;
				goto yy2;
			} else {
				if (yych <= '-') goto yy67;
				if (yych <= '/') goto yy2;
				if (yych <= '9') goto yy68;
				goto yy2;
			}
yy53:
			++YYCURSOR;
			{
    l.subline = l.line;
    l.subcolumn = l.column;
    SETANDJUMPTO(COMMENT_STR1);
}
yy55:
			++YYCURSOR;
			{
    SETANDJUMPTO(COMMENTS);
}
yy57:
			yych = *++YYCURSOR;
			if (yybm[0+yych] & 128) {
				goto yy70;
			}
			goto yy2;
yy58:
			yych = *++YYCURSOR;
			if (yych == 'f') goto yy73;
			goto yy32;
yy59:
			yych = *++YYCURSOR;
			if (yych == 'l') goto yy74;
			goto yy32;
yy60:
			yych = *++YYCURSOR;
			if (yych == 'f') goto yy75;
			goto yy32;
yy61:
			yych = *++YYCURSOR;
			if (yych == 'l') goto yy77;
			goto yy32;
yy62:
			yych = *++YYCURSOR;
			if (yych == 'u') goto yy78;
			goto yy32;
yy63:
			yych = *++YYCURSOR;
			if (yych == 'f') goto yy79;
			goto yy2;
yy64:
			yych = *++YYCURSOR;
			if (yych == 'f') goto yy80;
			goto yy2;
yy65:
			yych = *++YYCURSOR;
			if (yych == 'f') goto yy81;
			goto yy2;
yy66:
			yych = *++YYCURSOR;
			if (yych == 'f') goto yy82;
			goto yy2;
yy67:
			yych = *++YYCURSOR;
			if (yych <= '/') goto yy2;
			if (yych >= ':') goto yy2;
yy68:
			yych = *++YYCURSOR;
			if (yych <= '/') goto yy23;
			if (yych <= '9') goto yy68;
			goto yy23;
yy70:
			yych = *++YYCURSOR;
			if (yybm[0+yych] & 128) {
				goto yy70;
			}
			{
    FORWARD(0, l.start - begin);
    std::string str(begin, l.start);
    long ll = std::strtol(str.data(), nullptr, 16);
    return yy::parser::make_HEX(json::hex(ll, str), LOCATION);
}
yy73:
			yych = *++YYCURSOR;
			if (yych == 'i') goto yy84;
			goto yy32;
yy74:
			yych = *++YYCURSOR;
			if (yych == 's') goto yy85;
			goto yy32;
yy75:
			yych = *++YYCURSOR;
			if (yybm[0+yych] & 64) {
				goto yy31;
			}
yy76:
			{ FORWARD(0, l.start - begin); return yy::parser::make_INF(json::infinity(false), LOCATION);    }
yy77:
			yych = *++YYCURSOR;
			if (yych == 'l') goto yy86;
			goto yy32;
yy78:
			yych = *++YYCURSOR;
			if (yych == 'e') goto yy88;
			goto yy32;
yy79:
			yych = *++YYCURSOR;
			if (yych == 'i') goto yy90;
			goto yy2;
yy80:
			++YYCURSOR;
			goto yy76;
yy81:
			yych = *++YYCURSOR;
			if (yych == 'i') goto yy91;
			goto yy2;
yy82:
			++YYCURSOR;
			{ FORWARD(0, l.start - begin); return yy::parser::make_INF(json::infinity(true), LOCATION);     }
yy84:
			yych = *++YYCURSOR;
			if (yych == 'n') goto yy92;
			goto yy32;
yy85:
			yych = *++YYCURSOR;
			if (yych == 'e') goto yy93;
			goto yy32;
yy86:
			yych = *++YYCURSOR;
			if (yybm[0+yych] & 64) {
				goto yy31;
			}
			{ FORWARD(0, l.start - begin); return yy::parser::make_NUL(json::null(), LOCATION);             }
yy88:
			yych = *++YYCURSOR;
			if (yybm[0+yych] & 64) {
				goto yy31;
			}
			{ FORWARD(0, l.start - begin); return yy::parser::make_BOOLEAN(json::boolean(true), LOCATION);  }
yy90:
			yych = *++YYCURSOR;
			if (yych == 'n') goto yy95;
			goto yy2;
yy91:
			yych = *++YYCURSOR;
			if (yych == 'n') goto yy96;
			goto yy2;
yy92:
			yych = *++YYCURSOR;
			if (yych == 'i') goto yy97;
			goto yy32;
yy93:
			yych = *++YYCURSOR;
			if (yybm[0+yych] & 64) {
				goto yy31;
			}
			{ FORWARD(0, l.start - begin); return yy::parser::make_BOOLEAN(json::boolean(false), LOCATION); }
yy95:
			yych = *++YYCURSOR;
			if (yych == 'i') goto yy98;
			goto yy2;
yy96:
			yych = *++YYCURSOR;
			if (yych == 'i') goto yy99;
			goto yy2;
yy97:
			yych = *++YYCURSOR;
			if (yych == 't') goto yy100;
			goto yy32;
yy98:
			yych = *++YYCURSOR;
			if (yych == 't') goto yy101;
			goto yy2;
yy99:
			yych = *++YYCURSOR;
			if (yych == 't') goto yy102;
			goto yy2;
yy100:
			yych = *++YYCURSOR;
			if (yych == 'y') goto yy103;
			goto yy32;
yy101:
			yych = *++YYCURSOR;
			if (yych == 'y') goto yy105;
			goto yy2;
yy102:
			yych = *++YYCURSOR;
			if (yych == 'y') goto yy106;
			goto yy2;
yy103:
			yych = *++YYCURSOR;
			if (yybm[0+yych] & 64) {
				goto yy31;
			}
yy104:
			{ FORWARD(0, l.start - begin); return yy::parser::make_INF(json::infinity(false), LOCATION);    }
yy105:
			++YYCURSOR;
			goto yy104;
yy106:
			++YYCURSOR;
			{ FORWARD(0, l.start - begin); return yy::parser::make_INF(json::infinity(true), LOCATION);     }
		}
/* *********************************** */
yyc_KEY:
		yych = *YYCURSOR;
		if (yych <= '\v') {
			if (yych <= 0x08) {
				if (yych >= 0x01) goto yy112;
			} else {
				if (yych <= '\t') goto yy114;
				if (yych <= '\n') goto yy116;
				goto yy112;
			}
		} else {
			if (yych <= ' ') {
				if (yych <= '\f') goto yy114;
				if (yych <= 0x1F) goto yy112;
				goto yy114;
			} else {
				if (yych == '"') goto yy118;
				goto yy112;
			}
		}
		++YYCURSOR;
		{
    l.msg = "double-quotation-marks string unclosed";
    l.line = l.subline;
    l.column = l.subcolumn;
    goto syntax_error;
}
yy112:
		++YYCURSOR;
		{
    FORWARD(0, 1);
    SETANDJUMPTO(KEY);
}
yy114:
		++YYCURSOR;
		{
    FORWARD(0, 1);
    data = data.append(begin, l.start);
    begin=l.start;
    SETANDJUMPTO(KEY);
}
yy116:
		++YYCURSOR;
		{
    if (*(l.start-2) == '\r') {
        if (*(l.start-3) != '\\') {
            goto syntax_error;
        }
        data = data.append(begin, l.start-3);
    } else {
        if (*(l.start-2) != '\\') {
            goto syntax_error;
        }
        data = data.append(begin, l.start-2);
    }
    begin = l.start;
    FORWARD(1, 0);
    l.column = 0; 
    SETANDJUMPTO(KEY);
}
yy118:
		++YYCURSOR;
		{
    std::string v(begin, l.start-1);
    if (data.size() >= 1) {
        v = data + v;
    }
    data.clear();
    YYSETCONDITION(JSON);
    return yy::parser::make_STRING(v, LOCATION);
}
/* *********************************** */
yyc_KEY1:
		yych = *YYCURSOR;
		if (yych <= '\v') {
			if (yych <= 0x08) {
				if (yych >= 0x01) goto yy124;
			} else {
				if (yych <= '\t') goto yy126;
				if (yych <= '\n') goto yy128;
				goto yy124;
			}
		} else {
			if (yych <= ' ') {
				if (yych <= '\f') goto yy126;
				if (yych <= 0x1F) goto yy124;
				goto yy126;
			} else {
				if (yych == '\'') goto yy130;
				goto yy124;
			}
		}
		++YYCURSOR;
		{
    l.msg = "single-quotation-marks string unclosed";
    l.line = l.subline;
    l.column = l.subcolumn;
    goto syntax_error;
}
yy124:
		++YYCURSOR;
		{
    FORWARD(0, 1);
    SETANDJUMPTO(KEY1);
}
yy126:
		++YYCURSOR;
		{
    FORWARD(0, 1);
    data = data.append(begin, l.start);
    begin=l.start;
    SETANDJUMPTO(KEY1);
}
yy128:
		++YYCURSOR;
		{
    if (*(l.start-2) == '\r') {
        if (*(l.start-3) != '\\') {
            goto syntax_error;
        }
        data = data.append(begin, l.start-3);
    } else {
        if (*(l.start-2) != '\\') {
            goto syntax_error;
        }
        data = data.append(begin, l.start-2);
    }
    begin = l.start;
    FORWARD(1, 0);
    l.column = 0; 
    SETANDJUMPTO(KEY1);
}
yy130:
		++YYCURSOR;
		{
    std::string v(begin, l.start-1);
    if (data.size() >= 1) {
        v = data + v;
    }
    data.clear();
    YYSETCONDITION(JSON);
    return yy::parser::make_STRING(v, LOCATION);
}
/* *********************************** */
yyc_COMMENTS:
		yych = *YYCURSOR;
		if (yych == '\n') goto yy136;
		++YYCURSOR;
		{
    SETANDJUMPTO(COMMENTS);
}
yy136:
		++YYCURSOR;
		{
    FORWARD(1, 0);
    l.column = 0;
    SETANDJUMPTO(JSON);
}
/* *********************************** */
yyc_COMMENT_STR1:
		yych = *YYCURSOR;
		if (yych <= '\n') {
			if (yych <= 0x00) goto yy140;
			if (yych <= '\t') goto yy142;
			goto yy144;
		} else {
			if (yych == '*') goto yy146;
			goto yy142;
		}
yy140:
		++YYCURSOR;
		{
    l.msg = "multiline comments unclosed";
    l.line = l.subline;
    l.column = l.subcolumn;
    goto syntax_error;
}
yy142:
		++YYCURSOR;
yy143:
		{
    SETANDJUMPTO(COMMENT_STR1);
}
yy144:
		++YYCURSOR;
		{
    FORWARD(1, 0);
    l.column = 0;
    SETANDJUMPTO(COMMENT_STR1);
}
yy146:
		yych = *++YYCURSOR;
		if (yych != '/') goto yy143;
		++YYCURSOR;
		{
    SETANDJUMPTO(JSON);
}
	}


syntax_error:
return yy::parser::make_YYerror(LOCATION);
}